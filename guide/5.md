# 创建第二个 activity

## 启动 第二个Activity

在启动Activity之前，ActivityManager会检查确认指定的Class是否已在配置文件中声明。   
如已完成声明，则启动activity，应用正常运行。反之，则抛出ActivityNotFoundException异常。   
可能会导致应用崩溃。这就是我们必须在manifest配置文件中声明全部Activity的原因。   

## 显式与隐式intent

如通过指定Content与Class对象，然后调用intent的构造方法来创建Intent，则创建的是显式Intent。   
在同一应用中，我们使用显式Intent来启动activity。

## 使用 intent extra

传递数据 父->子

## 从子activity获取返回结果

public void startActivityForResult(Intent intent,int requestCode)
该方法的第一个参数同前述的intent.第二个参数是请求代码。请求代码是先发送给子activity，然后再返回给父activity的用户定义整数
值。
当一个activity启动多个类型不同的子activity，且需要判断区分消息回馈方时通常会用到该请求代码。

### 1.设置返回结果

实现子activity发送返回信息给父activity，有以下两种方法可供调用:

public final void setResult(int resultCode)
public final void setResult(int resultCode,Intent data)
一把来说，参数result code可以是以下两个预定义常量中的任何一个:
Activity.RESULT_OK
Activity.RESULT_CANCELED
(如果需要自己定义结果代码，还可以使用另一个常量:RESULT_FIRST_USER)
  在父activity需要子activity的完成结果采用不同的操作时，设置结果代码很有帮助。
 
 ## activity的使用与管理
 
 点击应用时，操作系统并没有启动应用，而是启动了应用中的一个activity。--launcher activity
 
 launcher activity在AndroidManifest.xml中配置
 
 ```xml
 <intent-filter>
    <action android:name="android.intent.action.Main">
        <caterory android:name="android.intent.category.LAUNCHER" />
    </action>
</intent-filter>
 ```
 Activity维护着一个非特定应用独享的回退栈，所有应有的activity都共享该回退栈。   
 不限于单个应用，回退栈作为一个整体共享给操作系统及设备使用。